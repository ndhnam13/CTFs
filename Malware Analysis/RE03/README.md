## Mục đích

Tìm hiểu cách nó hoạt động và C2 server mã độc kết nối đến

**Bài cho ta 1 file exe, 1 dll, và thư mục `data`

## Tổng quát

Mẫu mã độc này triển khai nhiều kỹ thuật nhằm tránh bị phát hiện và phân tích:  

- **Ẩn API**: Sử dụng kỹ thuật gọi API gián tiếp để tránh các phần mềm chống virus phát hiện, gây khó khăn cho phân tích tĩnh
- **Ràng buộc máy**: Key AES để giải mã payload được tạo động từ các thông tin duy nhất của máy (ví dụ Volume Serial Number), đảm bảo chỉ thực thi được trên mục tiêu định sẵn

**Giai đoạn 1: DLL Sideloading**

Mã độc khai thác kỹ thuật **DLL sideloading** với `colorui.dll`. Sau khi được nạp, nó duyệt thư mục **`C:\Users\Public`** để tìm file có chữ ký đặc trưng. File này là **`ntuser.pol`**, chứa payload mã hoá. Payload được giải mã và nạp vào bộ nhớ - **shellcode stage 2**.

**Giai đoạn 2:**

Shellcode stage 2:

1. Thu thập thông tin hệ thống
2. Tạo key và IV AES động từ các thông tin này
3. Chỉ khi key khớp (tức là chạy trên máy mục tiêu), shellcode mới giải mã và thực thi **shellcode stage 3**

**Giai đoạn 3: Beacon **

Shellcode stage 3 là một **Cobalt Strike Beacon** cấu hình sẵn để kết nối tới:  `portal.tandanssc.com`

## Giai đoạn 1

### LaunchColorCpl

Phân tích mã giả trong IDA trước, một vài hàm và biến đã được sửa tên để thuận tiện cho việc phân tích

```c
HMODULE LaunchColorCpl()
{
  HMODULE result; // rax
  const CHAR *v1; // rax
  __int64 (__fastcall *v2)(_QWORD, _QWORD, __int64 (*)(void), _QWORD, _DWORD, _QWORD); // rax
  __int64 v3; // rbx
  const CHAR *v4; // rax
  _QWORD v5[4]; // [rsp+30h] [rbp-28h] BYREF

  hModule = GetModuleHandleW(L"kernel32.dll");
  result = LoadLibraryW(L"Shlwapi.dll");
  qword_7FFC6D025208 = result;
  if ( hModule && result )
  {
    v1 = (const CHAR *)decode_api_name(v5, (__int64)&CreateThread);
    v2 = (__int64 (__fastcall *)(_QWORD, _QWORD, __int64 (*)(void), _QWORD, _DWORD, _QWORD))get_api_addr(v1, hModule);
    v3 = 0;
    if ( v2 )
      v3 = v2(0, 0, loader_entry, 0, 0, 0);
    v4 = (const CHAR *)decode_api_name(v5, (__int64)&WaitForSingleObject);
    result = (HMODULE)get_api_addr(v4, hModule);
    if ( result )
      return (HMODULE)((__int64 (__fastcall *)(__int64, __int64))result)(v3, 0xFFFFFFFFLL);
  }
  return result;
}
```

Hàm export của dll nạp Shlwapi.dll vào qword_7FFC6D025208
Gọi sub_7FFC6D001650 (decode_api_name) để lấy tên api bị mã hoá
Gọi sub_7FFC6D001510 (get_api_addr) để lấy địa chỉ api
Tạo một thread mới chạy hàm post_pgo_initialization cho đến khi hàm đó chạy xong mới dừng
Việc gọi API động như này khi phân tích tĩnh sẽ khá mất thời gian cho nên tôi đã chuyển sang debug sử dụng **x64dbg**. Muốn biết mã độc đã gọi API nào thì chỉ cần đặt breakpoint sau khi gọi hàm `decode_api_name`
API1: `CreateThread`, API2: `WaitForSingleObject`

`CreateThread` tạo một thread mới với entry point là `loader_entry` rồi trả về handle `v3` và `WaitForSingleObject` sẽ tạm dừng thread chính cho đến khi thread `v3`

### loader_entry và find_and_load_payload

Đây là 2 hàm hoạt động chính của chương trình

Thư mục `data` thực ra chính là thư mục `C:\\Users\\Public` trên máy người dùng dính mã độc

Có đường dẫn được hardcode sẵn: `C:\\Users\\Public`
Sau đó gọi hàm sub_7FFC6D003320 để duyệt thư mục và tìm file khớp, rồi trả về tên file khớp, sau khi debug biết được file đó là `ntuser.pol`
Sau khi tìm được file, thì mở (CreateFileW), lấy size (GetFileSize), di chuyển con trỏ file (SetFilePointer) rồi đọc file ntuser.pol (ReadFile)
Sau đó gọi hàm sub_7FFC6D005810 để xử lí

### sub_7FFC6D005810: decrypt_payload
Hàm này đọc và giải mã một phần dữ liệu (từ ntuser.pol), sau đó dùng VirtualProtect để thay đổi quyền truy cập bộ nhớ thành RWX và cuối cùng gọi EnumUILanguagesA với con trỏ tới vùng nhớ đã giải mã, khiến mã độc được thực thi
shellcode size: 42CF9

## Giai đoạn 2

Sau khi dump memory map ra thì sẽ phải cắt đoạn đó thành shellcode, bắt đầu từ vị trí 0xDF424 trong hexdump và size là 42CF9
Cho vào scdbg.exe ko được nên sử dụng sclauncher.exe để đưa shellcode về exe
Sau khi tìm hiểu 1 chút thì biết được hàm xử lí chính là sub_40286E

### MAIN_EXEC
Hàm này cũng áp dụng 1 phương pháp khác để encode, decode tên API và sau đó tìm địa chỉ của chúng như stage1 
Sau đó cấp phát bộ nhớ RWX cho payload bị mã hoá
Sau đó chương trình chọn thuật toán hash (MD5 hoặc SHA1), ở đây khi debug biết được chương trình chọn MD5
Sau đó thực hiện tìm 1 key theo 3 cách (Cả 3 cách này đều để chắc chắn rằng malware được thực hiện đúng 1 máy cụ thể):

- Cách 1: `a3 == 1` – dựa vào serial ổ đĩa. Dùng GetVolumeInformationA và vòng for để lặp qua các ổ

- Cách 2: `a3 == 2` – dựa vào NICs dùng GetAdaptersInfo

- Cách 3: `a3 == 3` – dựa vào DPAPI blob đính sau payload 

Cả 3 cách trên sẽ lấy 4byte và xor với biến a6 và kết quả = 0x00EF8B43 thì mới có thể decrypt được
Xem trong IDA biết giá trị của `a3 = 1` vậy sẽ làm theo kiểu dựa vào ổ đĩa
`MAIN_EXEC((__int64)&byte_403EB7, 0x3FE3Du, 1, 1, 1, 0x3088A37u);`
`__int64 __fastcall MAIN_EXEC(__int64 a1, unsigned int a2, int a3, int a4, int a5, unsigned int a6)`
Từ đó cũng biết được giá trị `a6 = 0x03088A37`
Còn lại là biến tmp của volumeID, giá trị này sẽ được chương trình xử lí như sau: Lấy volumeID, hash MD5, Lấy 4byte ở offset +10
Bây giờ sẽ phải bruteforce 4byte volumeid bởi vì ta không có volumeid mà malware cần
Sau khi brute ra giá trị `0x95FCE4BA` và `0xF22B5592` ta sẽ debug đến địa chỉ sau khi `GetVolumeInformationA` trả về volumeID rồi thay đổi bằng volumeID brute. Trong hàm này thì volumeID sẽ được truyền vào vùng nhớ của GetProcAddress (Thanh ghi R9 trỏ đến) nên ta sẽ follow in dump, đợi chạy đến ổ `C:\`, giá trị của vùng nhớ đó sẽ thay đổi, ta sẽ ép nó về đúng giá trị `0xF22B5592` dưới dạng little edian `0x92552BF2` (Mặc dù ra 2 kết quả nhưng chỉ có `0x92552BF2` là decrypt được shellcode, cái kia khi decrypt xong thì không ra gì)
Sau đó thì ta sẽ đặt 1 breakpoint sau khi chương trình gọi hàm decrypt AES-CTR và dump payload được giải mã
Nếu muốn kĩ hơn 1 chút (Tìm key và IV của AES_128_CTR) thì có thể đặt bp ở hàm `sub_4036F1` (`PREPARE_AES_CONTEXT`), địa chỉ của key là thanh ghi RDX và địa chỉ IV là R8. Khi debug thì cả 2 đều trỏ về 1 địa chỉ => key = IV = `cac1e9750332dea9755d7401e703f9d4`

## Giai đoạn 3: Cobalt Strike Beacon

Sau khi dump xong thì để ý ở đầu có signature `MZARUH` của cobaltstrike beacon, mình sẽ dùng [1768.py](https://raw.githubusercontent.com/DidierStevens/DidierStevensSuite/refs/heads/master/1768.py) để phân tích
Sau đây là 1 số config của nó

```
Xorkey: 0x2e (dấu .)

Payload type: windows-beacon_https-reverse_https

Server: portal.tandanssc.com

HTTP GET Host header: news.zing.vn

HTTP POST Host header: id.zing.vn

User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0

SpawnTo:

x86: %windir%\syswow64\bootcfg.exe

x64: %windir%\sysnative\bootcfg.exe

Public key: dài 2048 bit

Malleable C2 profile: rõ ràng là tùy chỉnh để ngụy trang thành traffic của Zing News & Zing ID

Cobalt Strike version guess: 4.2
```

